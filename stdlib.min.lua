--[[
    Tabletop Simulator Standard Library (tts-stdlib).
    Created by Red Mushroom.
    Profile: https://steamcommunity.com/id/Red_Mush
    Github: https://github.com/raeon/tts-stdlib
    License:
        Copyright (c) 2018 Joris Klein Tijssink

        Permission is hereby granted, free of charge, to any person obtaining a copy
        of this software and associated documentation files (the "Software"), to deal
        in the Software without restriction, including without limitation the rights
        to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
        copies of the Software, and to permit persons to whom the Software is
        furnished to do so, subject to the following conditions:

        The above copyright notice and this permission notice shall be included in all
        copies or substantial portions of the Software.

        THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
        IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
        FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
        AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
        LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
        OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
        SOFTWARE.
]]
do local a={name='Unnamed',description='',version=1,author='',profile='',license='',debugging=false}for b,c in pairs(a)do _G[b]=function(d)if d~=nil then a[b]=d end;return a[b]end end;local e=tostring;local function tostring(f)if type(f)=='table'then local g='{'local h=false;for b,c in pairs(f)do g=g..(h and', 'or'')..'"'..tostring(b)..'": '..tostring(c)h=true end;return g..'}'end;return e(f)end;local i=nil;function prefix(g)i=g end;local function j(k,l,m)return function(...)if l and not l()then return end;local g=i or'['..name()..' v'..tostring(version())..'] 'for b,c in pairs({...})do g=g..tostring(c)end;m(g,k)end end;local n={debug={color={r=0,g=255,b=255},condition=debugging},info={color={r=0,g=255,b=0}},warn={color={r=255,g=255,b=0}},fatal={color={r=255,g=0,b=0}}}for name,o in pairs(n)do local l=o.condition;local p=not l;_G[name]=j(o.color,o.condition,printToAll)_G[name..'Broadcast']=j(o.color,o.condition,broadcastToAll)end;local q=0;function assign()q=q+1;return q end;function _invoke(r)return{_G[r.func](table.unpack(r.args))}end;function invoke(f,name,...)return f.call('_invoke',{func=name,args={...}})end;local s={}local t={}local u={}local v=coroutine.yield;local w=false;function prewait(x)u[x]=false end;local function y(z,A,x,B)local C=assign()t[x]=t[x]or{}t[x][C]={id=z,co=A,call=B}return C end;local function D(z,A,E,B)local F=assign()s[F]={id=z,co=A,poll=E,call=B}_runPoller()return F end;function resume(x,...)local G=0;local H={...}debug('resume: ',x)for C,I in pairs(t[x]or{})do if I.call then I.call(H)else _cycle(I.id,I.co,H)end;G=G+1 end;if G>0 then u[x]=nil elseif u[x]==false then u[x]=H end;return G end;local function J(z,A,K)return false,{}end;local function L(z,A,K)return true,{z}end;local function M(z,A,K)local N=os.clock()+K.ms/1000;D(z,A,function()return os.clock()>=N end)return false,{}end;local function O(z,A,K)local P=u[K.key]u[K.key]=nil;if P then return true,P end;if not K.ms then y(z,A,K.key)return false,{}end;local N=os.clock()+K.ms/1000;local C,F;F=D(z,A,function()return os.clock()>=N end,function()t[K.key][C]=nil;_cycle(z,A,{false})end)C=y(z,A,K.key,function(H)s[F]=nil;_cycle(z,A,{true,H})end)debug('awaiting: ',K.key)return false,{}end;local function Q(z,A,K)local G=0;local R=1+(w and 1 or 0)+K.count;D(z,A,function()G=G+1;return G>R end)return false,{}end;local S={halt=J,identify=L,sleep=M,await=O,resume=_actionResume,cycle=Q}function identify()return v({action='identify'})end;function halt()return v({action='halt'})end;function sleep(T)return v({action='sleep',ms=T})end;function await(x,T)return v({action='await',key=x,ms=T})end;function cycle(G)return v({action='cycle',count=G or 1})end;function _cycle(z,A,H)local U,V,W,X,Y,Z,_;X=true;while X do U={coroutine.resume(A,table.unpack(H or{}))}V=U[1]Z=U[2]W=coroutine.status(A)~='dead'X=V and W;Y=V and W and 2 or 1;for a0=1,Y,1 do U[a0]=U[a0+Y]U[a0+Y]=nil end;if not V then fatal('coroutine #',z,' errored: ',Z)return end;if not X then break end;_=S[Z.action]if not _ then fatal('coroutine #',z,' tried to invoke unknown action: ',Z.action)return end;X,H=_(z,A,Z)end;return table.unpack(U)end;local a1=false;function _poller()local h=true;while h and a1 do h=false;w=true;for F,a2 in pairs(s)do h=true;if a2.poll()then if a2.call then a2.call()else _cycle(a2.id,a2.co)end;s[F]=nil end end;w=false;coroutine.yield(0)end;a1=false;return 1 end;function _runPoller()if a1 then return end;a1=true;startLuaCoroutine(self,'_poller')end;function async(m,name)if not m then return nil end;return function(...)local z=name and name..assign()or assign()local A=coroutine.create(m)return _cycle(z,A,{...})end end;function thread(m,a3)local z='thread'..assign()local A=coroutine.create(function()local a4=true;while a4 do local N=os.clock()local a5,P=pcall(m)if not a5 then fatal('thread error: ',P)return end;if not P then break end;a4=P;sleep(a3)end end)D(z,A,function()return true end)end;function _resumeSpawn(f,H)return resume(H.id,f)end;function _resumeDownload(R)return resume(R,R)end;function _resumeTake(f,H)return resume(H.id,f)end;local function a6(type,a7,a8)local H={a7}if a8 then table.insert(H,a8)end;table.insert(H,self)table.insert(H,'_resumeDownload')local R=await(WebRequest[type](table.unpack(H)))if R.is_error then return nil,R.error end;return{download_progress=R.download_progress,error=R.error,is_error=R.is_error,is_done=R.is_done,text=R.text,upload_progress=R.upload_progress,url=R.url},nil end;function webGet(a7)return a6('get',a7)end;function webPost(a7,a8)return a6('post',a7,a8)end;function webPut(a7,a8)return a6('put',a7,a8)end;local a9={'onChat','onCollisionEnter','onCollisionExit','onCollisionStay','onDestroy','onDrop','onExternalMessage','onFixedUpdate','onLoad','onObjectDestroy','onObjectDrop','onObjectEnterScriptingZone','onObjectLeaveContainer','onObjectLeaveScriptingZone','onObjectLoopingEffect','onObjectPickUp','onObjectRandomize','onObjectSpawn','onObjectTriggerEffect','onPickUp','onPlayerChangeColor','onPlayerTurnEnd','onPlayerTurnStart','onSave','onScriptingButtonDown','onScriptingButtonUp','onUpdate'}local aa={}function fire(ab,...)local ac=aa[ab]or{}local P=nil;for a0=1,#ac,1 do local ad=ac[a0]local ae={ad(...)}if#ae>0 then P=P or ae end end;return table.unpack(P or{})end;function listen(ab,ad)local ac=aa[ab]if not ac then _G[ab]=function(...)return fire(ab,...)end;ac={}aa[ab]=ac end;table.insert(ac,async(ad,ab))end;function on(ab,ad)listen('on'..ab,ad)end;local af={}on('ObjectLeaveContainer',function(ag,f)if ag.getQuantity()==0 then af.type='deck'af.stack=ag.getGUID()af.bottom=af.top;af.top=f.getGUID()if af.bottom then local H=af;af={}fire('onStackDisband',H.stack,H.bottom,H.top)end elseif ag.getQuantity()==1 then af.type='stack'af.stack=ag.getGUID()end end)on('ObjectSpawn',function(f)if af.type~='stack'then return end;af.bottom=af.top;af.top=f.getGUID()if af.bottom then local H=af;af={}fire('onStackDisband',H.stack,H.bottom,H.top)end end)local ah={}on('ObjectSpawn',function(f)if f.getQuantity()~=2 then return end;if f.tag=='Deck'then local ai=f.getObjects()if ai[1].guid~=ah.top or ai[2].guid~=ah.bottom then return end;local H=ah;ah={}fire('onStackForm',f.getGUID(),H.bottom,H.top)return end;if f.getGUID()~=ah.bottom then return end;local H=ah;ah={}fire('onStackForm',f.getGUID(),H.bottom,H.top)end)on('ObjectDestroy',function(f)ah.bottom=ah.top;ah.top=f.getGUID()end)local aj=self;local function ak(name,ad)local al=_G[name]_G[name]=function(...)return ad(al,...)end end;ak('spawnObject',function(m,r)local z=identify()r.callback='_resumeSpawn'r.callback_owner=aj;r.params={id=z}local f=m(r)local am,f=await(z)return await(z)end)ak('takeObject',function(m,an,r)r=r or{}local z=identify()r.callback='_resumeTake'r.callback_owner=aj;r.params={id=z}prewait(z)an.takeObject(r)return await(z)end)function upgrade(a7)if _PREVIOUS then debug('upgrade: detected v1, destroying prev: ',_PREVIOUS.guid)cycle()local ao=getObjectFromGUID(_PREVIOUS.guid)ao.destruct()debug('ugprade: assuming v1 position')self.setLock(false)self.setPosition(_PREVIOUS.position)self.setRotation(_PREVIOUS.rotation)self.setVelocity(_PREVIOUS.velocity)self.setLock(_PREVIOUS.lock)debug('upgrade: finished')return true end;if _ORIGINAL then debug('upgrade: detected v2, invoking resume')local al=getObjectFromGUID(_ORIGINAL)invoke(al,'resume','upgrade')debug('upgrade: finished')return true end;debug('upgrade: downloading new script')local R,ap=webGet(a7)if ap then debug('upgrade: failed to check for updates: ',ap)return false,ap end;if R.text==self.getLuaScript()then debug('upgrade: script is identical, aborting')return false end;debug('upgrade: old length: ',string.len(self.getLuaScript()))debug('upgrade: new length: ',string.len(R.text))debug('upgrade: cloning self')local f=self.clone({position={x=0,y=200,z=0}})f.setLock(true)f.interactable=false;f.setVar('_ORIGINAL',self.getGUID())debug('upgrade: awaiting callback')prewait('upgrade')f.setLuaScript(R.text)if not await('upgrade',200)then debug('upgrade: callback timed out')f.destruct()return false,'upgrade timed out'end;debug('upgrade: moving self away')local aq=self.getPosition()self.setPosition({x=0,y=210,z=0})debug('upgrade: moving upgraded version to our original position')f.setPosition(aq,false,true)f.setRotation(self.getRotation())f.setVelocity(self.getVelocity())f.setLock(self.getLock())f.interactable=self.interactable;debug('upgrade: finished')self.destruct()halt()end end
